/*******************************************************************************
 * Licensed to the Apache Software Foundation (ASF) under one or
 * more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information regarding
 * copyright ownership. The ASF licenses this file to you under the
 * Apache License, Version 2.0 (the "License"); you may not use
 * this file except in compliance with the License. You may obtain
 * a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0 Unless required by
 * applicable law or agreed to in writing, software distributed
 * under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 ******************************************************************************/
package org.apache.sling.xss.impl;

import java.lang.reflect.Field;

import org.apache.sling.api.SlingHttpServletRequest;
import org.apache.sling.api.resource.ResourceResolver;
import org.apache.sling.xss.XSSAPI;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.invocation.InvocationOnMock;
import org.mockito.stubbing.Answer;
import org.powermock.reflect.Whitebox;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.Matchers.anyString;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

public class XSSAPIImplTest {

    public static final String RUBBISH_XML = "<rubbish/>";

    private XSSAPI xssAPI;

    @BeforeEach
    public void setup() {
        try {
            XSSFilterImpl xssFilter = new XSSFilterImpl();

            xssAPI = new XSSAPIImpl();

            System.out.println("xssAPI set");

            Whitebox.invokeMethod(xssAPI, "activate");
            Field filterField = XSSAPIImpl.class.getDeclaredField("xssFilter");
            filterField.setAccessible(true);
            filterField.set(xssAPI, xssFilter);

            ResourceResolver mockResolver = mock(ResourceResolver.class);
            when(mockResolver.map(anyString())).thenAnswer(new Answer() {
                public Object answer(InvocationOnMock invocation) {
                    Object[] args = invocation.getArguments();
                    String url = (String) args[0];
                    return url.replaceAll("jcr:", "_jcr_");
                }
            });

            SlingHttpServletRequest mockRequest = mock(SlingHttpServletRequest.class);
            when(mockRequest.getResourceResolver()).thenReturn(mockResolver);

            xssAPI = xssAPI.getRequestSpecificAPI(mockRequest);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    @Test
    public void testGetValidXML() {
        String[][] testData = {
            {
                "<?xml version=\"1.0\"?><!DOCTYPE test SYSTEM \"http://nonExistentHost:1234/\"><test/>",
                "<?xml version=\"1.0\"?><!DOCTYPE test SYSTEM \"http://nonExistentHost:1234/\"><test/>"
            }
        };
        for (String[] aTestData : testData) {
            String source = aTestData[0];
            String expected = aTestData[1];

            String result = xssAPI.getValidXML(source, RUBBISH_XML);
            assertEquals(expected, result);
        }
    }
}
